# Среда исполнения декларативного языка

Чего мы хотим добиться?
1. Быстро выполнить какие-то понятные задачи, вроде вычисления простых числе
2. Сделать язык применимым к реальным проблемам
3. Когда мы выполняемся распределённо хочется минимизировать потребление трафика, возможно нужен интерфейс обращения к значения вычисления по сети
4. Надо дать пользователю удобный интефейс параллелизации (или научиться делать это автоматически)

Наш язык декларативный, поэтому все программы на нашем языке - выражения. Вычисления этих выражений хотелось бы распараллелить, причём сделать это хочется прозрачно для пользователя.

### Наброс идей

#### Распределённые вычисления

Сначала сфокусируеся на идеях для решения пунктов 1 и 2. Для этого рассмотрим модель лидера с наборов фоловеров для распределённых вычислений. При таком подходе и если наш язык, например, интерпретируемый, мы можем просто разделять некоторый выражения на части и вычислять части параллельно на разных фоловерах.

Где именно код будет разделяться на паралелльные вычисления? Для начала это может происходить в конструкциях языка:
- В кортеже каждое из значений может вычислять отдельно
- Тоже самое можно сделать в теории с любым другим контейнером, например со списком
- Вычисления на моноиде, такие как `sum`, `product`, `all`, `and` и т.д. тоже могут вычислять паралельно и эффективно за счёт ассоциотивности

Кроме этого мы можем добавить в наш язык и стриминг, за счёт ленивости вычислений в нашем языке - чтение из сети можно абстрагировать как список с неопределённой длиной, а запись воспользуется тем фактом, что финальный массив определён лениво.

#### Консенсус

Можем попробовать смоделировать акторную модель вычислений, которая позволит, например, реализовать алгоритм паксос.

Можем представить акторы как стримы из примера выше - они принимают входящее сообщение и возвращают новое. Возможно им понадобится для этого некоторое __состояние__.

#### Распределённая память

В теории мы можем сделать так, что любое вычисление происходит в своём исполнителе с использованием распределённой памяти и локов, чтобы избежать каких-либо повторных вычислений, сам по себе такой подход, конечно, не даст хорошей производительности, но возможно что-то такое можно где-то применить.

#### Динамическая паралеллизация
